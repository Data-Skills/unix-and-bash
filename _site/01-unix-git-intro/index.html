<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="last-modified" content="2018-03-13 10:00:58 +0300">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- meta "search-domain" used for google site search function google_search() -->
    <meta name="search-domain" value="">
    <link rel="stylesheet" type="text/css" href="../assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="../assets/css/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="../assets/css/lesson.css" />
    <link rel="stylesheet" type="text/css" href="../assets/css/syntax.css" />
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicon-swc.ico" />
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
	<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
	<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
	<![endif]-->
    <title>Intro to UNIX: Unix Basics</title>
  </head>
  <body>
    <div class="container">
      
<nav class="navbar navbar-default">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      
      

      
      <a class="navbar-brand" href="../index.html">Home</a>

    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">

	
        <li><a href="../CONDUCT.html">Code of Conduct</a></li>

        
	
        <li><a href="../setup.html">Setup</a></li>

        
        <li class="dropdown">
          <a href="../" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Episodes <span class="caret"></span></a>
          <ul class="dropdown-menu">
            
            <li><a href="../01-unix-git-intro/index.html">Unix Basics</a></li>
            
            <li><a href="../02-unix-data-tools/index.html">Unix Data Tools</a></li>
            
            <li><a href="../03-bash-scripts/index.html">Shell Scripting, Writing Pipelines, and Parallelizing Tasks</a></li>
            
	    <li role="separator" class="divider"></li>
            <li><a href="../aio.html">All in one page (Beta)</a></li>
          </ul>
        </li>
	

	
	
        <li class="dropdown">
          <a href="../" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Extras <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="../reference.html">Reference</a></li>
            
            <li><a href="../about/index.html">About</a></li>
            
            <li><a href="../discuss/index.html">Discussion</a></li>
            
            <li><a href="../figures/index.html">Figures</a></li>
            
            <li><a href="../guide/index.html">Instructor Notes</a></li>
            
          </ul>
        </li>
	

	
        <li><a href="../LICENSE.html">License</a></li>
	
	<li><a href="/edit/gh-pages/_episodes/01-unix-git-intro.md">Improve this page <span class="glyphicon glyphicon-pencil" aria-hidden="true"></span></a></li>
	
      </ul>
      <form class="navbar-form navbar-right" role="search" id="search" onsubmit="google_search(); return false;">
        <div class="form-group">
          <input type="text" id="google-search" placeholder="Search..." aria-label="Google site search">
        </div>
      </form>
    </div>
  </div>
</nav>


<div class="row">
  <div class="col-xs-1">
    <h3 class="text-left">
      
      <a href="../"><span class="glyphicon glyphicon-menu-up" aria-hidden="true"></span><span class="sr-only">lesson home</span></a>
      
    </h3>
  </div>
  <div class="col-xs-10">
    
    <h3 class="maintitle"><a href="../">Intro to UNIX</a></h3>
    
  </div>
  <div class="col-xs-1">
    <h3 class="text-right">
      
      <a href="../02-unix-data-tools/index.html"><span class="glyphicon glyphicon-menu-right" aria-hidden="true"></span><span class="sr-only">next episode</span></a>
      
    </h3>
  </div>
</div>

<article>
<div class="row">
  <div class="col-md-1">
  </div>
  <div class="col-md-10">
    <h1 class="maintitle">Unix Basics</h1>
  </div>
  <div class="col-md-1">
  </div>
</div>


<blockquote class="objectives">
  <h2>Overview</h2>

  <div class="row">
    <div class="col-md-3">
      <strong>Teaching:</strong> 50 min
      <br/>
      <strong>Exercises:</strong> 10 min
    </div>
    <div class="col-md-9">
      <strong>Questions</strong>
      <ul>
	
	<li><p>What is UNIX and why do I need to know it?</p>
</li>
	
	<li><p>How do I access Unix on my computer?</p>
</li>
	
	<li><p>What are most useful Unix commands?</p>
</li>
	
	<li><p>How do I work with streams and redirections?</p>
</li>
	
	<li><p>What is Unix pipe?</p>
</li>
	
	<li><p>How do I manage and interact with Unix processes?</p>
</li>
	
	<li><p>What is command substitution?</p>
</li>
	
	<li><p>What is Markdown?</p>
</li>
	
      </ul>
    </div>
  </div>

  <div class="row">
    <div class="col-md-3">
    </div>
    <div class="col-md-9">
      <strong>Objectives</strong>
      <ul>
	
	<li><p>To understand what Unix, Terminal, and Shell mean.</p>
</li>
	
	<li><p>To review the basic Unix commands, wildcards, and shell expansions.</p>
</li>
	
	<li><p>To be able to redirect streams of data in Unix.</p>
</li>
	
	<li><p>To be able to solve problems by piping several Unix commands.</p>
</li>
	
	<li><p>To be able to review, manage, and kill Unix processes.</p>
</li>
	
	<li><p>To be able to write simple Markdown files.</p>
</li>
	
      </ul>
    </div>
  </div>

</blockquote>

<h1 id="unix">UNIX</h1>
<p><img src="../images/unix1.gif" align="right" hspace="10" />
The objective of this tutorial is to introduce you to the Unix Shell. Although UNIX’s  Command-Line Interface 
may seem archaic, it is the single most powerful tool in a bioinformaticians toolbox. Some basic understanding 
of how to use the Command Line to move, modify and view files containing molecular and descriptive data is an 
absolute requirement for modern biological analysis.</p>

<h2 id="a-few-definitions">A few definitions:</h2>
<p><strong>UNIX</strong> A computer operating system originally developed in 1969 by a group of AT&amp;T employees at Bell Labs. Unix was designed to be portable, multi-tasking and multi-user in a time-sharing configuration. Unix systems are characterized by various concepts: the use of plain text for storing data; a hierarchical file system; treating devices and certain types of inter-process communication (IPC) as files; and the use of a large number of software tools, small programs that can be strung together through a command line interpreter using pipes, as opposed to using a single monolithic program that includes all of the same functionality. These concepts are known as the Unix philosophy.</p>

<p><strong>Terminal</strong>  A device, including a keyboard and a screen (or printer), used to send data to and receive data from a computer.</p>

<p><strong>Terminal.app</strong> is a terminal emulator included with your operating system. It allows the user to interact with the computer through a command line interface. On Mac OS X, Terminal is located in the /Applications/Utilities folder. You can personalize the appearance of the terminal window using the Terminal -&gt; Preferences menu option.</p>

<p><strong>Shell</strong>  A program that allows the system (UNIX) to understand your commands. There are three main uses for the shell: interactive use (reading input from your terminal and sending output to it); customization of your UNIX session; programming. Several shells are available in UNIX. We will be using the Bourne again shell (bash).</p>

<h2 id="unix-basics">Unix basics:</h2>

<p>Before we do anything in unix we need to know these ten essential Unix commands for navigation and file manipulation:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pwd</span><span class="p">,</span><span class="w"> </span><span class="n">ls</span><span class="p">,</span><span class="w"> </span><span class="n">cd</span><span class="p">,</span><span class="w"> </span><span class="n">cp</span><span class="p">,</span><span class="w"> </span><span class="n">mv</span><span class="p">,</span><span class="w"> </span><span class="n">mkdir</span><span class="p">,</span><span class="w"> </span><span class="n">rm</span><span class="p">,</span><span class="w"> </span><span class="n">man</span><span class="p">,</span><span class="w"> </span><span class="n">cat</span><span class="o">/</span><span class="n">zcat</span><span class="p">,</span><span class="w"> </span><span class="n">echo</span><span class="w"> </span><span class="c1">#separated by ,</span><span class="w">
</span></code></pre></div></div>

<p>You should also be familiar with the meaning of the following wildcards and shell expansion characters:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">A</span><span class="o">-</span><span class="n">Z</span><span class="p">],</span><span class="w"> </span><span class="o">/</span><span class="p">,</span><span class="w"> </span><span class="n">.</span><span class="o">/</span><span class="p">,</span><span class="w"> </span><span class="n">..</span><span class="o">/</span><span class="p">,</span><span class="w"> </span><span class="o">~</span><span class="w"> </span><span class="c1">#separated by , </span><span class="w">
</span></code></pre></div></div>

<p>Finally, you need to know the difference between the absolute and relative path, e.g.,</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cd</span><span class="w"> </span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">bin</span><span class="w">
</span><span class="n">cd</span><span class="w"> </span><span class="n">..</span><span class="o">/</span><span class="n">lib</span><span class="w">
</span></code></pre></div></div>

<p>To make sure that we are all on the same page, predict the action of the following commands and check your 
predictions by typing them in the terminal:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cd</span><span class="p">;</span><span class="w">
</span><span class="n">pwd</span><span class="p">;</span><span class="w">
</span><span class="n">ls</span><span class="w"> </span><span class="o">-</span><span class="n">tl</span><span class="p">;</span><span class="w">
</span><span class="n">mkdir</span><span class="w"> </span><span class="o">-</span><span class="n">p</span><span class="w"> </span><span class="n">test</span><span class="o">-</span><span class="n">dir</span><span class="o">/</span><span class="n">lab1</span><span class="p">;</span><span class="w">
</span><span class="n">cd</span><span class="w"> </span><span class="n">test</span><span class="o">-</span><span class="n">dir</span><span class="o">/</span><span class="n">lab1</span><span class="p">;</span><span class="w">
</span><span class="n">mkdir</span><span class="w"> </span><span class="n">temp1</span><span class="w"> </span><span class="n">temp2</span><span class="w"> </span><span class="n">temp3</span><span class="p">;</span><span class="w">
</span><span class="n">mv</span><span class="w"> </span><span class="n">temp1</span><span class="w"> </span><span class="n">temp2</span><span class="w"> </span><span class="n">temp3</span><span class="p">;</span><span class="w">
</span><span class="n">rm</span><span class="w"> </span><span class="o">-</span><span class="n">rf</span><span class="w"> </span><span class="n">temp</span><span class="o">*</span><span class="p">;</span><span class="w">
</span><span class="n">cd</span><span class="w"> </span><span class="n">..</span><span class="p">;</span><span class="w">
</span><span class="n">cd</span><span class="w"> </span><span class="o">-</span><span class="p">;</span><span class="w">
</span><span class="n">pwd</span><span class="p">;</span><span class="w">
</span></code></pre></div></div>

<blockquote class="callout">
  <h2 id="tip-shell-expansion">Tip: Shell Expansion</h2>

  <p>As you start spending more time in a terminal, you’ll start to collect tricks to make this process as 
efficient as possible. One useful trick is shell expansion. Shell expansion is when your shell expands 
text for you so you don’t have to type it out. As we just saw above, the shell expands the tilde character 
(~) to the full path to your 
home directory. A type of shell expansion called brace expansion can be used to quickly create the 
simple directory structure with a single command. Brace expansion creates strings by expanding out 
the comma-separated values inside the braces. This is easier to understand through a trivial example:</p>

  <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">echo</span><span class="w"> </span><span class="n">dog</span><span class="o">-</span><span class="p">{</span><span class="n">gone</span><span class="p">,</span><span class="n">bowl</span><span class="p">,</span><span class="n">bark</span><span class="p">}</span><span class="w">
</span></code></pre></div>  </div>

  <div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dog-gone dog-bowl dog-bark
</code></pre></div>  </div>
  <p>Using the same strategy, we can create a project directory:
<code class="highlighter-rouge">mkdir -p zmays-snps/{data/seqs,scripts,analysis}</code>
Note that we need to use mkdir’s -p flag, which tells mkdir to create any necessary 
subdirectories it needs (in our case, data/ to create data/seqs/).</p>

</blockquote>

<blockquote class="callout">
  <h2 id="tip-autocompletion-and-history">Tip: autocompletion and history</h2>

  <p>There are two other extremely useful features provided by most shells: autocompletion and history.</p>

  <ol>
    <li>
      <p>If you hit the <code class="highlighter-rouge">tab</code> key after you started typing the name of a command or a file, the shell 
will try to fill in the rest of it for you! If the beginning is ambiguous, it will show you available
choices. For example, enter <code class="highlighter-rouge">c&lt;tab&gt;&lt;tab&gt;</code> and you will see the name of every program you can run 
that starts with an c. One of those is cat. Now, cat is easy to type, but there may be other 
commands with longer names (e.g., fastx_nucleotide_distribution_graph.sh)!</p>
    </li>
    <li>
      <p>Most shells will keep a history of recent commands! To access this history use your up and down errors. 
The up arrow takes you backwards through your command history. The down arrow takes your forwards in the command history.</p>
    </li>
  </ol>

</blockquote>

<h2 id="working-with-streams-and-redirection">Working with Streams and Redirection</h2>
<p>Bioinformatics data is often text-based and large. This is why Unix’s philosophy of handling text streams 
is useful in bioinformatics: text streams allow us to do processing on a stream of data rather than holding 
it all in memory. Handling and redirecting the streams of data is essential skill in Unix.</p>

<h3 id="redirecting-standard-out-to-a-file">Redirecting Standard Out to a File</h3>

<p>By default, both standard error and standard output of most unix programs go to your terminal screen. 
We can change this behavior (redirect the streams to a file) by using <code class="highlighter-rouge">&gt;</code> or <code class="highlighter-rouge">&gt;&gt;</code> operators. 
The operator <code class="highlighter-rouge">&gt;</code> redirects standard output to a file and overwrites any existing contents of the file, 
whereas <code class="highlighter-rouge">&gt;&gt;</code> appends to the file. If there isn’t an existing file, both operators will create it before 
redirecting output to it. For example, to concatenate two FASTA files, we use <code class="highlighter-rouge">cat</code> command, but redirect 
the output to a file:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cat</span><span class="w"> </span><span class="n">tb1</span><span class="o">-</span><span class="n">protein.fasta</span><span class="w"> </span><span class="n">tga1</span><span class="o">-</span><span class="n">protein.fasta</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">zea</span><span class="o">-</span><span class="n">proteins.fasta</span><span class="w">
</span></code></pre></div></div>

<p>Note that nothing is printed to your terminal screen when you redirect standard output to a file</p>

<p><img src="../images/fig3.1.png" alt="" /></p>

<p>How can we verify that the command worked?</p>

<h3 id="redirecting-standard-error">Redirecting Standard Error</h3>

<p>Because many programs use the standard output stream for outputting data, a separate stream 
(standard error) is used for errors, warnings, and messages meant to be read by the user 
(depicted in Figure 3-1). Like standard output, standard error is by default directed to 
your terminal. Standard error stream can be redirected to a file with 2&gt; to create
a log of messages, errors, and warnings that we can check later. If you want to redirect both
streams to the same file, use <code class="highlighter-rouge">command &amp;&gt; logfile</code> or <code class="highlighter-rouge">command &amp;&gt;&gt; logfile</code>.</p>

<p>Redirection can be a useful way to silence diagnostic information some programs write to standard 
out: we just redirect to a logfile like stderr.txt. Unix-like operating systems also have a special 
“fake” disk (known as a pseudodevice) to redirect unwanted output to: /dev/null. Output written 
to /dev/null disappears, which is why it’s sometimes jokingly referred to as a “black‐hole”.</p>

<blockquote class="callout">
  <h2 id="tip-tail--f">Tip: <code class="highlighter-rouge">tail -f</code></h2>

  <p>One way to write output to monitor redirected stanard output or error is to use
<code class="highlighter-rouge">tail -f</code> with the output/error filename.</p>

</blockquote>

<h3 id="using-standard-input-redirection">Using Standard Input Redirection</h3>
<p>Normally standard input comes from your keyboard, but with the <code class="highlighter-rouge">&lt;</code> redirection operator 
you can read standard input from a file. Though standard input redirection is less common 
than &gt;, », and 2&gt;, it is still occasionally useful:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">program</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">inputfile</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">outputfile</span><span class="w">
</span></code></pre></div></div>

<p>Many programs we’ll see later (like <code class="highlighter-rouge">grep</code>, <code class="highlighter-rouge">awk</code>, <code class="highlighter-rouge">sort</code>) can take a file argument in addition 
to input through standard input. Other programs (common especially in bioinformatics) use a single 
dash argument (-) to indicate that they should use standard input, but this is a convention rather 
than a feature of Unix.</p>

<h2 id="the-almighty-unix-pipe-speed-and-beauty-in-one">The Almighty Unix Pipe: Speed and Beauty in One</h2>
<p>Unix pipes are similar to the redirect operators we saw earlier, except rather than redirecting a 
program’s standard output stream to a file, pipes redirect it to another program’s standard input. 
Only standard output is piped to the next command; standard error still is printed to your terminal 
screen.</p>

<p>Passing the output of one program directly into the input of another program with pipes is a computationally 
efficient and simple way to interface Unix programs. Pipes allow us to build larger, more complex tools 
from smaller modular parts. It doesn’t matter what language a program is written in, either; pipes will 
work between anything as long as both programs understand the data passed between them. As the lowest 
common denominator between most programs, plain-text streams are often used.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">grep</span><span class="w"> </span><span class="o">-</span><span class="n">v</span><span class="w"> </span><span class="s2">"^&gt;"</span><span class="w"> </span><span class="n">..</span><span class="o">/</span><span class="n">data</span><span class="o">/</span><span class="n">tb1.fasta</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">grep</span><span class="w"> </span><span class="o">--</span><span class="n">color</span><span class="w"> </span><span class="o">-</span><span class="n">i</span><span class="w"> </span><span class="s2">"[^ATCG]"</span><span class="w">
</span></code></pre></div></div>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CCCCAAAGACGGACCAATCCAGCAGCTTCTACTGCTAYCCATGCTCCCCTCCCTTCGCCGCCGCCGACGC
</code></pre></div></div>

<h3 id="combining-pipes-and-redirection">Combining Pipes and Redirection</h3>

<p>Obviously, we can combine pipes and redirections:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">program1</span><span class="w"> </span><span class="n">input.txt</span><span class="w"> </span><span class="m">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">program1.stderr</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">program2</span><span class="w"> </span><span class="m">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">program2.stderr</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">results.txt</span><span class="w">
</span></code></pre></div></div>

<h3 id="even-more-redirection-a-tee-in-your-pipe">Even More Redirection: A tee in Your Pipe</h3>

<p>One advantage of using pipes is that we don’t need to write/read intermediate files.
However, occasionally such files can be useful when debugging a pipeline or when you 
wish to store intermediate files for steps that take a long time to complete. The Unix 
program <code class="highlighter-rouge">tee</code> diverts a copy of your pipeline’s standard output stream to an intermediate 
file while still passing it through its standard output:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">program1</span><span class="w"> </span><span class="n">input.txt</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">tee</span><span class="w"> </span><span class="n">intermediate</span><span class="o">-</span><span class="n">file.txt</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">program2</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">results.txt</span><span class="w">
</span></code></pre></div></div>

<h2 id="managing-and-interacting-with-processes">Managing and Interacting with Processes</h2>
<p>When we run programs through the Unix shell, they become processes until they successfully 
finish or terminate with an error. There are multiple processes running on your machine 
simultaneously—for example, system processes, as well as your web browser, email application, 
bioinformatics programs, and so on. In bioinformatics, we often work with processes that run f
or a large amount of time, so it’s important we know how to work with and manage processes 
from the Unix shell.</p>

<h3 id="background-processes">Background Processes</h3>
<p>When we type a command in the shell and press Enter, we lose access to that shell prompt for 
however long the command takes to run (we say that the program is running in the foreground). 
We can tell the Unix shell to run a program in the background by appending an ampersand (&amp;) 
to the end of our command. For example:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">program1</span><span class="w"> </span><span class="n">input.txt</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">results.txt</span><span class="w"> </span><span class="o">&amp;</span><span class="w">
</span></code></pre></div></div>

<p>or by stopping a program with <code class="highlighter-rouge">Control-z</code> and sending it to background with <code class="highlighter-rouge">bg</code>.</p>

<p>When we send a program to background, the shell returns a number which is the process ID or PID 
of program1. This is a unique ID that allows you to identify and check the status of program1 
later on. We can check what processes we have running in the background with <code class="highlighter-rouge">jobs</code>:
To bring a background process into the foreground again, we can use <code class="highlighter-rouge">fg</code> (for foreground). <code class="highlighter-rouge">fg</code> 
will bring the most recent process to the foreground. To return a specific background job to the 
foreground, use <code class="highlighter-rouge">fg %&lt;num&gt;</code> where <code class="highlighter-rouge">&lt;num&gt;</code> is its number in the job list.</p>

<h3 id="killing-processes">Killing Processes</h3>
<p>It’s not uncommon for a process to demand too many of our computer’s resources or become nonresponsive, 
requiring that we send a special signal to kill the process: <code class="highlighter-rouge">Control-c</code>. This only works if this process 
is running in the foreground. Killing a process ends it for good, and unlike suspending it with a stop 
signal, it’s unrecoverable. You can also kill a process with a <code class="highlighter-rouge">kill</code> command:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">kill</span><span class="w"> </span><span class="m">-9</span><span class="w"> </span><span class="o">&lt;</span><span class="n">PID</span><span class="o">&gt;</span><span class="w"> </span><span class="c1"># PID is process id</span><span class="w">
</span><span class="c1">#or</span><span class="w">
</span><span class="n">kill</span><span class="w"> </span><span class="m">-9</span><span class="w"> </span><span class="o">%&lt;num&gt; # %</span><span class="n">num</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">job</span><span class="w"> </span><span class="n">number</span><span class="w">
</span></code></pre></div></div>

<h3 id="exit-status-how-to-programmatically-tell-whether-your-command-worked">Exit Status: How to Programmatically Tell Whether Your Command Worked</h3>
<p>One concern with long-running processes is that you’re probably not going to wait around to 
monitor them. How do you know when they complete? How do you know if they successfully finished 
without an error? Unix programs exit with an exit status, which indicates whether a program terminated 
without a problem or with an error. By Unix standards, an exit status of 0 indicates the process ran 
successfully, and any nonzero status indicates some sort of error has occurred (and hopefully the program 
prints an understandable error message, too). The exit status isn’t printed to the terminal, but your shell 
will set its value to a shell variable named <code class="highlighter-rouge">$?</code>. We can use the echo command to look at this variable’s 
value after running a command:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">program1</span><span class="w"> </span><span class="n">input.txt</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">results.txt</span><span class="p">;</span><span class="w"> </span><span class="n">echo</span><span class="w"> </span><span class="o">$?</span><span class="w">
</span></code></pre></div></div>

<p>Exit statuses are useful because they allow us to programmatically chain commands together 
in the shell. A subsequent command in a chain is run conditionally on the last command’s exit status. 
The shell provides two operators that implement this: one operator that runs the subsequent command 
only if the first command completed successfully (&amp;&amp;), and one operator that runs the next command 
only if the first completed unsuccessfully (||).</p>

<p>For example, the sequence <code class="highlighter-rouge">program1 input.txt &gt; intermediate-results.txt &amp;&amp; program2 intermediate-results.txt &gt; results.txt</code>
will execute the second command only if previous commands have completed with a nonzero exit status.</p>

<p>By contrast, <code class="highlighter-rouge">program1 input.txt &gt; intermediate-results.txt || echo "warning: an error occurred"</code> 
will print the message if error has occurred.</p>

<blockquote class="challenge">
  <h2 id="challenge-1">Challenge 1</h2>

  <p>To test your understanding of <code class="highlighter-rouge">&amp;&amp;</code> and <code class="highlighter-rouge">||</code>, we’ll use two Unix commands that do nothing but return 
either exit success (<code class="highlighter-rouge">true</code>) or exit failure (<code class="highlighter-rouge">false</code>). Predict and check the outcome of the following 
commands:</p>

  <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">true</span><span class="w">
</span><span class="n">echo</span><span class="w"> </span><span class="o">$?</span><span class="w">
</span><span class="n">false</span><span class="w">
</span><span class="n">echo</span><span class="w"> </span><span class="o">$?</span><span class="w">
</span><span class="n">true</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">echo</span><span class="w"> </span><span class="s2">"first command was a success"</span><span class="w">
</span><span class="n">true</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">echo</span><span class="w"> </span><span class="s2">"first command was not a success"</span><span class="w"> 
</span><span class="n">false</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">echo</span><span class="w"> </span><span class="s2">"first command was not a success"</span><span class="w">
</span><span class="n">false</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">echo</span><span class="w"> </span><span class="s2">"first command was a success"</span><span class="w">
</span></code></pre></div>  </div>

  <blockquote class="solution">
    <h2 id="solution-to-challenge-1">Solution to challenge 1</h2>

    <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">true</span><span class="w">
</span><span class="n">echo</span><span class="w"> </span><span class="o">$?</span><span class="w">
</span><span class="n">false</span><span class="w">
</span><span class="n">echo</span><span class="w"> </span><span class="o">$?</span><span class="w">
</span><span class="n">true</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">echo</span><span class="w"> </span><span class="s2">"first command was a success"</span><span class="w">
</span><span class="n">true</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">echo</span><span class="w"> </span><span class="s2">"first command was not a success"</span><span class="w"> 
</span><span class="n">false</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">echo</span><span class="w"> </span><span class="s2">"first command was not a success"</span><span class="w">
</span><span class="n">false</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">echo</span><span class="w"> </span><span class="s2">"first command was a success"</span><span class="w">
</span></code></pre></div>    </div>

    <div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0
1
first command was a success
first command was not a success
</code></pre></div>    </div>
  </blockquote>
</blockquote>

<p>If f you don’t care about the exit status and you just wish to execute two commands sequentially, 
you can use a single semicolon (;):</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">false</span><span class="p">;</span><span class="w"> </span><span class="n">true</span><span class="p">;</span><span class="w"> </span><span class="n">false</span><span class="p">;</span><span class="w"> </span><span class="n">echo</span><span class="w"> </span><span class="s2">"none of the previous mattered"</span><span class="w">
</span></code></pre></div></div>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>none of the previous mattered
</code></pre></div></div>

<h2 id="command-substitution">Command Substitution</h2>
<p>Unix users like to have the Unix shell do work for them—this is why shell expansions like wildcards 
and brace expansion exist. Another type of useful shell expansion is command substitution. Command 
substitution runs a Unix command inline and returns the output as a string that can be used in another 
command. This opens up a lot of useful possibilities. For example, if you want to include the results 
from executing a command into a text, you can type:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">echo</span><span class="w"> </span><span class="s2">"There are $(grep -c '^&gt;' ../data/improper.fa) entries in my FASTA file."</span><span class="w">
</span></code></pre></div></div>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>There are 2 entries in my FASTA file.
</code></pre></div></div>

<p>This command uses grep to count (the -c option stands for count) the number of lines matching the pattern. 
Using command substitution, we can calculate and return the number of FASTA entries directly into this string!</p>

<p>Another example of using command substitution would be creating dated directories:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mkdir</span><span class="w"> </span><span class="n">results</span><span class="o">-$</span><span class="p">(</span><span class="n">date</span><span class="w"> </span><span class="o">+%F) #or
mkdir results-`date +%</span><span class="nb">F</span><span class="err">`</span><span class="w">
</span></code></pre></div></div>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir: results-2018-03-13: File exists
</code></pre></div></div>

<p>In general, the format returned by date +%F is a really good one for dated directories, because when 
results are sorted by name, directories in this format also sort chronologically:</p>

<h1 id="markdown">Markdown</h1>

<h2 id="markdown-for-project-notebooks">Markdown for Project Notebooks</h2>
<p>Bioinformaticians usually like keeping project notebooks in simple plain-text because these can be read, 
searched, and edited from the command line and across network connections to servers. Plain text is 
also a future-proof format: plain-text files written in the 1960s are still readable today, whereas 
files from word processors only 10 years old can be difficult or impossible to open and edit. Additionally, 
plain-text project notebooks can also be put under version control. While plain-text is easy to write in 
your text editor, it can be inconvenient for collaborators unfamiliar with the command line to read. 
A lightweight markup language called Markdown is a plain-text format that is easy to read and painlessly 
incorporated into typed notes, and can also be rendered to HTML or PDF.</p>

<h2 id="markdown-formatting-basics">Markdown Formatting Basics</h2>
<p>Markdown’s formatting features match all of the needs of a bioinformatics notebook: text can be broken 
down into hierarchical sections, there’s syntax for both code blocks and inline code, and it’s easy to 
embed links and images. While the Markdown format is very simple, there are a few different variants. 
We’ll use the original Markdown format, invented by John Gruber, in our examples. John Gruber’s full 
markdown syntax specification is available on his <a href="https://daringfireball.net/projects/markdown/syntax">website</a>.</p>

<p>Here is an example of a Markdown text and its HTML rendering:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Markdown text</th>
      <th style="text-align: center">HTML rendering</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><img src="../images/fig1.1.png" alt="" /></td>
      <td style="text-align: center"><img src="../images/fig1.2.png" alt="" /></td>
    </tr>
  </tbody>
</table>

<h2 id="rmarkdown">RMarkdown</h2>

<p>R Markdown is a file format for making dynamic documents with R. An R Markdown document is written in markdown
but contains chunks of embedded code written in R, Phyton, bash, etc. Rendered R Markdown documents will 
contain output from executing this code.  Download this <a href="https://www.rstudio.com/wp-content/uploads/2016/03/rmarkdown-cheatsheet-2.0.pdf">RMarkdown cheat sheet</a> as a reference. Visit <a href="https://rmarkdown.rstudio.com/">RMarkdown website</a> for more information.</p>



<blockquote class="keypoints">
  <h2>Key Points</h2>
  <ul>
    
    <li><p>Unix is the single most powerful tool in a bioinformaticians toolbox.</p>
</li>
    
    <li><p>Use pwd, ls, cd, cp, mv, mkdir, rm, man, cat/zcat, echo to list, move, copy, and view files and directories</p>
</li>
    
    <li><p>Use <code class="highlighter-rouge">&gt;</code> to redirect stadard output to a file</p>
</li>
    
    <li><p>Use <code class="highlighter-rouge">|</code> to redirect standard output to another program</p>
</li>
    
    <li><p>Use <code class="highlighter-rouge">&lt;command&gt;&amp;</code> to run a program in a background</p>
</li>
    
    <li><p>Use <code class="highlighter-rouge">jobs</code> to see jobs you are running in a shell</p>
</li>
    
    <li><p>Use <code class="highlighter-rouge">$()</code> include an output from a program in a string</p>
</li>
    
  </ul>
</blockquote>

</article>

<div class="row">
  <div class="col-xs-1">
    <h3 class="text-left">
      
      <a href="../"><span class="glyphicon glyphicon-menu-up" aria-hidden="true"></span><span class="sr-only">lesson home</span></a>
      
    </h3>
  </div>
  <div class="col-xs-10">
    
  </div>
  <div class="col-xs-1">
    <h3 class="text-right">
      
      <a href="../02-unix-data-tools/index.html"><span class="glyphicon glyphicon-menu-right" aria-hidden="true"></span><span class="sr-only">next episode</span></a>
      
    </h3>
  </div>
</div>


      
      
<footer>
  <div class="row">
    <div class="col-md-6" align="left">
      <h4>
	Copyright &copy; 2016–2018
	
	<a href="https://software-carpentry.org">Software Carpentry Foundation</a>
	
      </h4>
    </div>
    <div class="col-md-6" align="right">
      <h4>
	
	<a href="/edit/gh-pages/_episodes/01-unix-git-intro.md">Edit on GitHub</a>
	
	/
	<a href="/blob/gh-pages/CONTRIBUTING.md">Contributing</a>
	/
	<a href="/">Source</a>
	/
	<a href="/blob/gh-pages/CITATION">Cite</a>
	/
	<a href="mailto:dlavrov@iastate.edu">Contact</a>
      </h4>
    </div>
  </div>
</footer>

      
    </div>
    
<script src="../assets/js/jquery.min.js"></script>
<script src="../assets/js/bootstrap.min.js"></script>
<script src="../assets/js/lesson.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-37305346-2', 'auto');
  ga('send', 'pageview');
</script>

  </body>
</html>
